### 本次变更摘要（v2 近期）
- EXACT 与 negate：
  - 新增 `match=EXACT`（等值匹配器）；`pattern` 支持 `string|string[]`（数组为 OR）。
  - 新增规则级 `negate:boolean`，在 OR 聚合后取反，用于表达“非白名单即拒绝”等语义。
- URL 解码与归一化策略：
  - 明确并统一“一次性解码”规则：`URI/ARGS_COMBINED/BODY` 各自单次解码，不交叉复用已解码结果；禁止二次解码。
  - 已通过 `src/core/ngx_http_waf_utils.[ch]` 封装、并在规则匹配路径落地（详见“7.1 URL 解码与归一化策略”）。
- 日志可观测性（取反命中）：
  - 仅对“最终命中”为真的规则记录 `rule` 事件；“取反取消”（取反后未命中）不记录事件，避免噪音。
  - 事件中仅保留 `negate` 字段标注规则是否取反；无需 `matchedBefore/matchedFinal`。

---

### 先明确两点（你刚提到的关键决定）
- STAGE 宏里不再做任何 flush，只做“根据阶段返回枚举 → 映射成 Nginx rc 的早退”。是否落盘、何时落盘，一律由 action 层函数内部决定（BLOCK/BYPASS 立即落盘）；管线尾部的“FINAL flush”由 handler 显式调用 action 层的 `waf_action_finalize_allow(...)` 完成。
- `final_action/final_status` 仅由 action 层在 BLOCK/BYPASS 时写入；module 层完全不关心它们，且不需要 unset 语义（默认 0 即可）。

---

### 接口统一化调整（新增）

- 统一采用“waf_enforce_*”族函数，取消单独的 `waf_add_score`；将“基础访问加分”改为可导致拦截的执法接口：`waf_enforce_base_add(...)`（返回 `waf_rc_e`）。
- 包装器与入口：

```c
// 统一入口（底座），由各包装器调用；支持携带 scoreDelta
waf_rc_e waf_enforce(ngx_http_request_t* r,
                    ngx_http_waf_main_conf_t* mcf,
                    ngx_http_waf_loc_conf_t*  lcf,
                    ngx_http_waf_ctx_t*       ctx,
                    /* intent */    int intent_block_1_log_0_bypass_2,
                    /* http */      ngx_int_t http_status_if_block,
                    /* rule id */   ngx_uint_t rule_id_or_0,
                    /* score */     ngx_uint_t score_delta);

// 语义包装：规则/策略触发 BLOCK（可带分数）
static inline waf_rc_e
waf_enforce_block(ngx_http_request_t* r, ngx_http_waf_main_conf_t* mcf,
                  ngx_http_waf_loc_conf_t* lcf, ngx_http_waf_ctx_t* ctx,
                  ngx_int_t http_status, ngx_uint_t rule_id_or_0, ngx_uint_t score_delta);

// 语义包装：仅记录事件（可带分数），不拦截
static inline waf_rc_e
waf_enforce_log(ngx_http_request_t* r, ngx_http_waf_main_conf_t* mcf,
                ngx_http_waf_loc_conf_t* lcf, ngx_http_waf_ctx_t* ctx,
                ngx_uint_t rule_id_or_0, ngx_uint_t score_delta);

// 语义包装：本次请求软放行并绕过后续阶段（立即 FINAL flush）
static inline waf_rc_e
waf_enforce_bypass(ngx_http_request_t* r, ngx_http_waf_main_conf_t* mcf,
                   ngx_http_waf_loc_conf_t* lcf, ngx_http_waf_ctx_t* ctx,
                   ngx_uint_t rule_id_or_0);

// 基础访问加分（可触发封禁）：返回 waf_rc_e 以便被 STAGE 宏统一处理
waf_rc_e waf_enforce_base_add(ngx_http_request_t* r,
                              ngx_http_waf_main_conf_t* mcf,
                              ngx_http_waf_loc_conf_t*  lcf,
                              ngx_http_waf_ctx_t*       ctx,
                              ngx_uint_t score_delta);
```

- 约定：
  - `waf_enforce*` 与其包装器统一返回 `waf_rc_e`：`CONTINUE|BLOCK|BYPASS|ERROR`，已综合全局策略 BLOCK/LOG 与动态信誉判断。
  - `waf_enforce_*` 内部负责：聚合意图→（可选）加分→复检封禁→写入 `ctx->final_*`→记录事件→在 BLOCK/BYPASS 时立即 `waf_log_flush_final(...)`；LOG/base_add 不落盘。
  - 阶段函数只需“调用包装器并按返回的 `waf_rc_e` 原样返回”；编排层用 `WAF_STAGE` 宏完成早退映射。

### 详细设计书（对齐 `refactor-plan-v2.md` 与 `waf-json-spec-v2.0-simplified.md`）

#### 1. 模块划分与职责边界

- module 层（`src/module/`）
  - 入口/指令/merge；ACCESS 阶段“5 段流水线”执行；请求体异步挂载与回调推进；只调用 action API；不接触动态信誉与日志细节（尾部 FINAL 也通过 action 完成）。
- action 层（`src/core/ngx_http_waf_action.[ch]`）
  - 统一动作出口：BLOCK/BYPASS/LOG 与评分的归并；设置 `ctx->final_action/final_status`；记录日志事件；对 BLOCK/BYPASS 立即 flush；对 LOG/加分不 flush。返回值一律为 `waf_rc_e`，已综合全局策略（BLOCK/LOG）。
- 动态信誉层（`src/core/ngx_http_waf_dynamic_block.[ch]`）
  - 共享内存（rbtree+queue+slab）；评分窗口/阈值/封禁与过期；提供 `waf_dyn_*` API，被 action 调用。
- 日志层（`src/core/ngx_http_waf_log.[ch]`）
  - 请求内事件聚合；`waf_log_append_*`；`waf_log_flush_final` 输出一行 JSONL；级别：off|debug|info|alert；含去重/只 flush 一次的保护。
- 规则 JSON/编译层（`src/json/ngx_http_waf_json.[ch]`、`src/core/ngx_http_waf_compiler.[ch]`）
  - 解析/extends/禁用/去重；生成只读快照（分桶/预编译 regex/CIDR）；loc_conf 挂载。
- 工具层（`src/core/ngx_http_waf_utils.[ch]`）
  - XFF/IPv4、URI decode 等通用工具。

依赖方向（强约束）：`module → action → {dynamic, log}`。
- 严禁跨层：module 不得直接调用 dynamic/log；dynamic/log 不得回调 module。
- 仅 action 允许同时依赖 dynamic 与 log；所有“全局动作策略（BLOCK/LOG）裁决、评分/封禁、最终落盘”只在 action 层发生。
- module 层只关心阶段返回的 `waf_rc_e` 与 `ctx->final_status`（用于映射 HTTP 状态），不读写其它日志/信誉细节。

---

### 项目目录结构与生命周期（当前快照）

- 仓库根：`/home/william/myNginxWorkspace/nginx-http-waf-module-v2`

- 关键目录与文件（基于当前仓库）：

```
src/
  module/
    ngx_http_waf_module.c      // 挂载指令/阶段，注册 handler；入口编排
    ngx_http_waf_config.c      // 指令解析与 {main,srv,loc}_conf merge
    ngx_http_waf_utils.c       // 运行期通用工具（XFF/解码等）
  core/
    ngx_http_waf_action.c      // 统一动作出口（BLOCK/BYPASS/LOG/评分）
    ngx_http_waf_log.c         // 请求日志聚合与最终 JSONL 落盘
    ngx_http_waf_dynamic_block.c // 动态信誉：评分/阈值/封禁 + 共享内存
    ngx_http_waf_compiler.c    // 规则编译：JSON→只读快照（regex/CIDR 等）
  json/
    ngx_http_waf_json.c        // 规则 JSON 解析/extends/禁用/去重
  include/
    ngx_http_waf_action.h
    ngx_http_waf_log.h
    ngx_http_waf_dynamic_block.h
    ngx_http_waf_compiler.h
    ngx_http_waf_utils.h
    ngx_http_waf_stage.h       // STAGE 宏与公共枚举引用
    ngx_http_waf_types.h       // 公共枚举/ctx 前置声明
third_party/
  yyjson/                      // 规则解析依赖（yyjson.c/h）
  uthash/                      // 可选索引结构依赖
config                         // Nginx addon 构建脚本（列出 SRCS 与 -I 路径）
```

---

#### 启动期（配置解析→规则构建）顺序与依赖

- 总览：`配置指令解析 → 规则 JSON 解析 → 规则编译 → 快照挂载 → 阶段注册/共享内存初始化`。

- 详细步骤（按发生顺序）：
  1) `ngx_http_waf_module.c` 注册指令与钩子；Nginx 进入 `create_conf/merge_conf` 周期：
     - `ngx_http_waf_config.c` 负责各级 `{main,srv,loc}` 配置对象的创建与合并（含路径、开关、阈值等）。
  2) 若配置中启用了规则集/路径：
     - `json/ngx_http_waf_json.c` 读取并解析规则 JSON（依赖 `third_party/yyjson`），完成 `extends/禁用/去重/校验`，输出“原始规则模型”。
  3) `core/ngx_http_waf_compiler.c` 将“原始规则模型”编译为“只读快照”（预编译正则、构建索引、分桶布局）；必要处可用 `uthash` 辅助索引。
  4) 将“只读快照”挂载到 `loc_conf`（或 `main_conf` 的只读共享指针），供运行期快速查询；此后运行期不再依赖 yyjson/文件 IO。
  5) `postconfiguration`：
     - 初始化动态信誉共享内存与数据结构：`core/ngx_http_waf_dynamic_block.c`（`ngx_shm`, `rbtree+queue+slab`）。
     - 向 `NGX_HTTP_ACCESS_PHASE` 注册处理函数：`module/ngx_http_waf_module.c`（内部使用 `WAF_STAGE` 宏组织流水）。

- 依赖关系（启动期）：
  - `module/config` → `json` → `third_party/yyjson`。
  - `json` → `compiler`（数据流交接）。
  - `compiler` → `include/types`（公共类型/枚举）。
  - `postconfiguration` 阶段：`module` → `dynamic_block` 初始化；`module` 注册阶段回调。

---

#### 请求期（WAF 处理流水）顺序与依赖

- 总览：`module 入口 → 阶段函数流水（WAF_STAGE） → action 执法 → {dynamic, log} → 返回 Nginx`。

- 流水编排（参考本文件“执行流水与异步体处理/阶段范式”）：
  1) `module/ngx_http_waf_module.c` 作为 ACCESS 阶段入口，创建/取得 `ctx`，依次调用：
     - `waf_stage_ip_allow`（硬放行，BYPASS 短路）
     - `waf_stage_ip_deny`（硬拒绝，BLOCK 短路）
     - `waf_stage_reputation_base_add`（基础访问加分 → 可能 BAN）
     - `waf_stage_uri_allow`（软放行，BYPASS 短路）
     - `waf_stage_detect_bundle`（规则检测集合：SQLi/XSS/UA/…）
     - 尾部：若未早退，调用 `waf_action_finalize_allow(...)`：
       - 若 `r->method ∈ {GET, HEAD}` 或 `content_length_n == 0`：`waf_stage_detect_bundle` 直接在 handler 内执行，随后做尾部 FINAL；返回 `NGX_DECLINED`。
       - 否则（需要请求体）：在进入 `detect_bundle` 前，调用 `ngx_http_read_client_request_body(r, ngx_http_waf_post_read_body_handler)` 并立即返回 `NGX_DONE`；`detect_bundle` 与尾部 FINAL 在回调中执行与推进相位。
  2) 阶段函数内部根据命中情况调用 `core/ngx_http_waf_action.c`：
     - `waf_enforce_block|bypass|log|base_add` 统一出口，返回 `waf_rc_e`；
     - BLOCK/BYPASS 路径内立即设置 `ctx->final_*` 并做最终 JSONL 落盘。
  3) `action` 内部依赖：
     - 动态信誉：`core/ngx_http_waf_dynamic_block.c`（`waf_dyn_*` 评分/阈值/BAN 与复检）。
     - 日志聚合：`core/ngx_http_waf_log.c`（`waf_log_append_*` 与 `waf_log_flush_final`）。
  4) 运行期工具：`module/ngx_http_waf_utils.c`（XFF 提取、URI 解码等）在阶段/规则评估中被按需调用。
  5) 最终由 `WAF_STAGE` 宏将 `waf_rc_e` 映射回 Nginx rc（`NGX_DECLINED/NGX_DONE/HTTP_xxx`）。

- 依赖关系（请求期）：
  - `module` → `action`（单向）。
  - `action` → `{dynamic_block, log}`（单向）。
  - `module`/`action` → `utils`（按需）。
  - 规则快照为只读结构（来自启动期 `compiler` 输出），请求期只读访问；与 `{dynamic, log}` 无环依赖。

- 时序摘要（文字版）：
```
[ACCESS handler] module.c
   → WAF_STAGE(...ip_allow...) → (BYPASS?)
   → WAF_STAGE(...ip_deny...)  → (BLOCK?)
   → WAF_STAGE(...base_add...) → action(base_add) → dynamic(re-score/ban?)
   → WAF_STAGE(...uri_allow...)→ (BYPASS?)
   → 判定是否需要请求体：
       ├─ 不需要（GET/HEAD 或 content_length_n==0）：
       │    → WAF_STAGE(...detect...)   → action(block/log) → {dynamic,log}
       │    → (尾) action_finalize_allow → log(final ALLOW if eligible)
       │    → return NGX_DECLINED
       └─ 需要（如 POST/PUT 且有体）：
            → ngx_http_read_client_request_body(r, post_read_body_handler) → return NGX_DONE
            （进入回调）
            post_read_body_handler:
              → WAF_STAGE(...detect...)   → action(block/log) → {dynamic,log}
              → (尾) action_finalize_allow → log(final ALLOW if eligible)
              → r->phase_handler++；ngx_http_core_run_phases(r)
```

---

##### 异步请求体读取与回调时序（实现对齐 `ngx_http_waf_module.c`）

- 入口判定（ACCESS 阶段内）：
  - 若 `r->method ∈ {GET, HEAD}` 或 `r->headers_in.content_length_n == 0`：不读体，直接跑 `waf_stage_detect_bundle`，随后 `waf_action_finalize_allow(...)` 并返回 `NGX_DECLINED`。
  - 否则：调用 `ngx_http_read_client_request_body(r, ngx_http_waf_post_read_body_handler)`，立即返回 `NGX_DONE`，等待回调推进。

- 回调 `ngx_http_waf_post_read_body_handler(r)`：
  - 取得 `ctx/mcf/lcf`，空指针直接 `ngx_http_finalize_request(r, 500)`。
  - 执行检测段：`rc = waf_stage_detect_bundle(r, mcf, lcf, ctx)`；根据返回值：
    - `WAF_RC_BLOCK`：以 `ctx->final_status`（缺省 403）`ngx_http_finalize_request(r, status)` 结束请求。
    - `WAF_RC_ERROR`：`ngx_http_finalize_request(r, 500)`。
    - `WAF_RC_BYPASS`：BYPASS 已在 action 内完成最终落盘，`r->phase_handler++；ngx_http_core_run_phases(r)` 推进到下一个相位。
    - `WAF_RC_CONTINUE`：调用 `waf_action_finalize_allow(r, mcf, lcf, ctx)`（按阈值决定 ALLOW 是否落盘），随后 `r->phase_handler++；ngx_http_core_run_phases(r)`。

- 请求体拼接与 BODY 匹配：
  - `ngx_http_waf_collect_request_body(r, ngx_str_t* body)` 会合并内存/文件缓冲，生成以 `\0` 结尾的 `body` 视图；
  - `waf_stage_detect_bundle` 中针对 `WAF_T_BODY` 目标，按规则的 `CONTAINS/REGEX` 使用该 `body` 完成匹配。

- 幂等与落盘：
  - BLOCK/BYPASS 路径在 action 内立即做最终 JSONL 落盘；
  - 尾部 ALLOW 落盘受 `waf_json_log_level` 控制；
  - 统一由 `ctx->log_flushed` 防重复写出。

注：上述逻辑与当前实现文件 `module/ngx_http_waf_module.c` 的入口、回调与工具函数命名保持一致，确保读者可直接映射到代码。

---

#### 2. 运行时上下文与关键字段

- `ngx_http_waf_ctx_t`（摘取关键字段）
  - `client_ip_addr:uint32`, `client_ip_str:ngx_str_t`
  - `total_score:uint32`（可选快照）
  - `final_action:waf_final_action_e`（0/none，1/block，2/bypass）
  - `final_status:ngx_int_t`（仅 BLOCK/BYPASS 写入，默认 0）
  - `log_doc/*events*/`（日志聚合句柄）
  - `log_flushed:ngx_flag_t`（是否已最终落盘，防重）
  - 说明：`final_*` 只由 action 写；module 不读不写（除末尾判断是否需要 FINAL flush，可读 `log_flushed`）。

---

#### 3. 阶段返回枚举与 STAGE 宏

- 返回枚举（轻量最小集）
```c
typedef enum {
    WAF_RC_CONTINUE = 0,   // 继续后续阶段
    WAF_RC_BYPASS,         // 本模块后续阶段不再执行（外层映射 NGX_DECLINED）
    WAF_RC_BLOCK,          // 阻断（外层返回 HTTP_xxx）
    WAF_RC_ASYNC,          // 预留：阶段内部进入异步（外层映射 NGX_DONE）；当前 v2 初版通常不用
    WAF_RC_ERROR           // 内部错误（外层返回 500）
} waf_rc_e;

typedef enum {
    WAF_FINAL_NONE  = 0,
    WAF_FINAL_BLOCK = 1,
    WAF_FINAL_BYPASS= 2,
} waf_final_action_e;
```

- STAGE 宏（仅用于编排层：handler/请求体回调；不在阶段函数内部使用）
```c
// src/include/ngx_http_waf_stage.h
#ifndef _NGX_HTTP_WAF_STAGE_H_INCLUDED_
#define _NGX_HTTP_WAF_STAGE_H_INCLUDED_

#include "ngx_http_waf_action.h"

#define WAF_STAGE(ctx, CALL)                                                    \
    do {                                                                        \
        waf_rc_e _waf_rc = (CALL);                                              \
        if (_waf_rc == WAF_RC_ASYNC)   { return NGX_DONE; }                     \
        if (_waf_rc == WAF_RC_BLOCK)   {                                        \
            return (ctx)->final_status > 0 ? (ctx)->final_status                \
                                           : NGX_HTTP_FORBIDDEN;                \
        }                                                                        \
        if (_waf_rc == WAF_RC_BYPASS)  { return NGX_DECLINED; }                 \
        if (_waf_rc == WAF_RC_ERROR)   { return NGX_HTTP_INTERNAL_SERVER_ERROR; }\
    } while (0)

#endif
```
- 价值说明（单独头 `ngx_http_waf_stage.h`）：
  - 只依赖 `waf_rc_e` 与 `ctx->final_status`，避免把日志/动态信誉等细节拉进 module 层。
  - 让 module 层的 handler/回调代码高度简洁一致，便于审阅与重构。

---

#### 4. action 层设计（统一动作出口）

- 约定
  - 任意阶段函数如需“执法或软放行”，必须调用 action API；阶段函数自身与包装器统一返回 `waf_rc_e`，供 STAGE 宏早退。
  - BLOCK/BYPASS 在 action 内立即做“最终落盘”（final flush），并设置 `ctx->final_action/final_status` 与 `log_flushed=1`，避免 module 再 flush。
  - 纯 LOG 或 评分不落盘，仅聚合事件；最终在管线尾部由 module 调用 action 的 `waf_action_finalize_allow(...)` 做一次 FINAL（若未早退）。

- API（头/源同名：`ngx_http_waf_action.[ch]`）
```c
// 统一入口（底座），供包装器调用；已综合全局策略 BLOCK/LOG 与动态信誉
waf_rc_e waf_enforce(ngx_http_request_t* r,
                    ngx_http_waf_main_conf_t* mcf,
                    ngx_http_waf_loc_conf_t*  lcf,
                    ngx_http_waf_ctx_t*       ctx,
                    /* intent */    int intent_block_1_log_0_bypass_2,
                    /* http */      ngx_int_t http_status_if_block,
                    /* rule id */   ngx_uint_t rule_id_or_0,
                    /* score */     ngx_uint_t score_delta);

// 轻量包装（建议在阶段里优先使用）
static inline waf_rc_e
waf_enforce_block(ngx_http_request_t* r, ngx_http_waf_main_conf_t* mcf,
                  ngx_http_waf_loc_conf_t* lcf, ngx_http_waf_ctx_t* ctx,
                  ngx_int_t http_status, ngx_uint_t rule_id_or_0, ngx_uint_t score_delta) {
    return waf_enforce(r, mcf, lcf, ctx, /*BLOCK*/1, http_status, rule_id_or_0, score_delta);
}

static inline waf_rc_e
waf_enforce_bypass(ngx_http_request_t* r, ngx_http_waf_main_conf_t* mcf,
                   ngx_http_waf_loc_conf_t* lcf, ngx_http_waf_ctx_t* ctx,
                   ngx_uint_t rule_id_or_0) {
    return waf_enforce(r, mcf, lcf, ctx, /*BYPASS*/2, NGX_DECLINED, rule_id_or_0, 0);
}

// 仅加分（无执法），可触发封禁；返回 waf_rc_e 便于早退
waf_rc_e waf_enforce_base_add(ngx_http_request_t* r,
                              ngx_http_waf_main_conf_t* mcf,
                              ngx_http_waf_loc_conf_t*  lcf,
                              ngx_http_waf_ctx_t*       ctx,
                              ngx_uint_t                 score_delta);

// 尾部 FINAL（ALLOW）统一出口，由 module 在 handler/回调尾部调用
void waf_action_finalize_allow(ngx_http_request_t* r,
                               ngx_http_waf_main_conf_t* mcf,
                               ngx_http_waf_loc_conf_t*  lcf,
                               ngx_http_waf_ctx_t*       ctx);
```

- 行为细则
  - BLOCK 路径：
    - 先按需加分（`score_delta>0`）→ `waf_dyn_score_add` → 复检是否达阈值（可直接 BAN）；
    - 设置 `ctx->final_action=BLOCK` 与 `ctx->final_status=http_status`；
    - 记录事件；随后 `waf_log_flush_final(r,mcf,lcf,ctx,"BLOCK")`（仅一次）。
    - 返回 `WAF_RC_BLOCK`。
  - BYPASS 路径：
    - 设置 `ctx->final_action=BYPASS`；记录事件；立即 `waf_log_flush_final(...,"BYPASS")`（仅一次）；
    - 返回 `WAF_RC_BYPASS`。
  - LOG/评分：
    - 聚合事件；不 flush；返回 `WAF_RC_CONTINUE`。

- 幂等保护
  - `waf_log_flush_final` 内部检查 `ctx->log_flushed`；若已落盘则直接返回，避免多处触发导致重复行。

---

#### 5. 日志层设计（一次请求一行 JSONL）

- 接口（`ngx_http_waf_log.[ch]`）
```c
void waf_log_init_ctx(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx);

void waf_log_append_rule_event(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx,
                               ngx_uint_t rule_id, const char* target_tag,
                               ngx_uint_t score_delta, ngx_uint_t total_score,
                               const ngx_str_t* matched_pattern, ngx_uint_t pattern_index,
                               ngx_flag_t negate,
                               const char* intent_str /* "BLOCK"|"LOG"|"BYPASS" */);

void waf_log_append_reputation_event(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx,
                                     ngx_int_t delta, ngx_uint_t total_score,
                                     const char* reason_tag);

void waf_log_flush_final(ngx_http_request_t* r,
                         ngx_http_waf_main_conf_t* mcf,
                         ngx_http_waf_loc_conf_t*  lcf,
                         ngx_http_waf_ctx_t*       ctx,
                         const char* final_action_hint /* "BLOCK"|"BYPASS"|"ALLOW"|NULL */);
```

- 事件字段扩展：
  - `type`（reputation|rule|ban|bypass）、`ruleId?`、`intent`、`scoreDelta?`、`totalScore`、
    `matchedPattern?`、`patternIndex?`、`target`、`negate?`。
  - negate取消不产生日志事件。
  - 当规则为取反且最终命中（即“未匹配”导致命中）时，可将 `matchedPattern` 置为 null 或直接省略。

- 级别与落盘策略
  - **可配置级别**：`off|debug|info|alert|error`。
  - **内部枚举**：还包含 `none`（特殊占位符，表示"未记录"状态，不可配置）。
  - **级别顺序**：`none < debug < info < alert < error < off`。
  - **none 语义**：`ctx->effective_level` 初始值为 `none`；只有当请求产生事件或被提升级别时才会落盘，避免正常无事件请求产生日志噪音。
  - BLOCK：将 `effective_level` 至少提升到 `alert`，必落盘。
  - BYPASS/ALLOW：按阈值（`waf_json_log_level`）决定是否落盘。
  - 只落盘一次（`ctx->log_flushed`）。

- 输出
  - JSONL 一行（包含 `finalAction`、`finalActionType` 与 `status`）；`error_log` 可选摘要（非强制）。

##### JSONL 结构（统一草案）

```json
{
  "time": "2025-09-14T12:34:56.789Z",
  "clientIp": "1.2.3.4",
  "method": "POST",
  "uri": "/login?x=1",
  "events": [
    { "type": "reputation", "scoreDelta": 1,  "totalScore": 1,  "reason": "base_access" },
    { "type": "rule",       "ruleId": 200010, "intent": "BLOCK", "scoreDelta": 20, "totalScore": 21,
      "matchedPattern": null, "patternIndex": 0, "target": "ALL_PARAMS",
      "negate": true, "decisive": true },
    { "type": "ban",        "window": 60000 }
  ],
  "finalAction": "BLOCK",
  "finalActionType": "BLOCK_BY_RULE",
  "blockRuleId": 200010,
  "status": 403
}
```

- 取值约定：
  - `events[].type`：`reputation|rule|ban|bypass|base_access`。
  - `events[].decisive:boolean`：可选；标记该事件是否为首次导致 `finalAction=BLOCK` 的决定性事件；同一请求最多 1 个 `true`。
  - `finalActionType`：`BLOCK_BY_RULE|BLOCK_BY_REPUTATION|BLOCK_BY_IP_BLACKLIST|BYPASS_BY_IP_WHITELIST|BYPASS_BY_URI_WHITELIST|ALLOW`。
  - `blockRuleId:uint`：可选；当 `finalActionType=BLOCK_BY_RULE` 时需要联动出现，表示导致阻断的规则 ID（与 `events` 中 `decisive=true` 的 `rule` 事件一致）。
  - `finalAction`：`BLOCK|BYPASS|ALLOW`。
  - 级别：根据 `finalAction` 自动提升（`BLOCK→alert`），其余受 `waf_json_log_level` 控制。

- 实现约定（日志填充）：
  - 首次确立 `finalAction=BLOCK` 的当刻，判定来源：
    - 若由规则命中导致：将当前 `rule` 事件标记 `decisive=true`，设置顶层 `blockRuleId=该 ruleId`，并令 `finalActionType=BLOCK_BY_RULE`。
    - 若由信誉/封禁导致（如动态信誉 `ban` 或累积分数超阈）：将该事件标记 `decisive=true`，令 `finalActionType=BLOCK_BY_REPUTATION`，且不得写入 `blockRuleId`。
  - `decisive=true` 在同一请求中最多出现一次；一旦设置，后续事件不再改写 `decisive` 或 `blockRuleId`。
  - 仅当 `finalAction=BLOCK` 时，事件中才可能出现 `decisive=true`；在 `ALLOW/BYPASS` 情况下不应出现 `decisive=true`，顶层也不应出现 `blockRuleId`。
  - 兼容性：`decisive` 字段为可选；`blockRuleId` 仅在 `finalActionType=BLOCK_BY_RULE` 时需要联动出现。

---

#### 6. 动态信誉层（M5 并行推进）

- 接口（`ngx_http_waf_dynamic_block.[ch]`）
```c
void      waf_dyn_score_add(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx, ngx_int_t delta);
ngx_flag_t waf_dyn_is_banned(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx);
void      waf_dyn_ban(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx, ngx_msec_t duration);
```

- 设计要点
  - 共享内存：`ngx_rbtree_t + ngx_queue_t(LRU)` + `ngx_slab_pool` + `ngx_shmtx_t`。
  - 窗口滑动、过期、阈值命中执法；必要时分片多 zone 降竞争。

---

#### 7. 执行流水与异步体处理（与 v1 一致）

- 5 段流水（参照 `refactor-plan-v2.md`）
  1) IP 允许（硬放行，BYPASS 短路）  
  2) IP 拒绝（硬拒绝，BLOCK 短路）  
  3) 信誉评分/封禁（基础访问加分 → BAN 复检 → 可能 BLOCK）  
  4) URI 允许（软放行，BYPASS 短路）  
  5) 检测段（SQLi/XSS/UA/非法方法/Cookie/CSRF…，可带 score → 统一动作出口）

- 同步/异步分支
  - GET/HEAD 或 `content_length_n == 0`：直接跑检测段（BODY 视为空串），跑完尾部做 FINAL flush（若未早退）。
  - 其他：`ngx_http_read_client_request_body(r, post_read_body_handler)`；返回 `NGX_DONE`。回调中：
    - 收集请求体（合并内存/文件缓冲；按 `x-www-form-urlencoded` 解码）；
    - 跑整个“检测段”（含规则/评分/执法），使用 `WAF_STAGE` 宏早退；
    - 若未早退，`waf_log_flush_final(...,"ALLOW")`；推进 `r->phase_handler++; ngx_http_core_run_phases(r)`。

- 关于 `WAF_RC_ASYNC`
  - 当前模式下通常不由阶段函数返回（异步由 module 层统一触发/接管）；保留该枚举为未来阶段内部发起异步（如子请求/挑战）时使用。

---

##### 7.1 URL 解码与归一化策略（统一取值）

- 总则：匹配前对不同 `target` 的取值进行一次性的解码/归一化，避免双重解码与不一致。
- URI：使用 Nginx 已解析的 `r->uri`/`r->unparsed_uri` 的解码结果，不再二次 URL 解码。
- ARGS_COMBINED/ALL_PARAMS：
  - 从原始查询串构建键值对，对 `%XX` 与 `+`→空格做一次 URL 解码；
  - 仅做一次解码；禁止对已解码片段再次解码；
  - 组合视图用于 `CONTAINS/REGEX/EXACT`，遵循 `caseless/negate`。
- BODY：
  - 当 `Content-Type=application/x-www-form-urlencoded`：收集完整请求体后做一次 URL 解码（与 Query 一致规则）；
  - 其他类型（如 `application/json`、`multipart/*`、二进制）：不解码，按原文匹配。
- HEADER：按原文匹配，不做 URL 解码。
- 工具封装（`src/core/ngx_http_waf_utils.[ch]`，返回池内只读视图）：
  - `waf_get_decoded_uri(r, ngx_str_t* out)`
  - `waf_get_decoded_args_combined(r, ngx_str_t* out)`
  - `waf_collect_request_body(r, ngx_str_t* out)` / `waf_decode_form_urlencoded(const ngx_str_t* in, ngx_str_t* out)`
- 注意：
  - 严禁“先解码再拼接”与“拼接后再次解码”的混用；
  - 编译期的 `ALL_PARAMS` 展开顺序为 `URI|ARGS_COMBINED|BODY`，运行期各自独立获取各自的解码视图。

---

#### 8. 阶段函数编写范式（无编排层，仅返回枚举）

- 示例（非法方法）
```c
static waf_rc_e
waf_stage_illegal_method(ngx_http_request_t* r,
                         ngx_http_waf_main_conf_t* mcf,
                         ngx_http_waf_loc_conf_t*  lcf,
                         ngx_http_waf_ctx_t*       ctx)
{
    if (!lcf->default_illegal_method_defense_enabled) return WAF_RC_CONTINUE;

    if (/* 命中非法方法 */) {
        // 评分 + 执法（立即 final flush）
        (void)waf_enforce_block(r, mcf, lcf, ctx,
                                NGX_HTTP_FORBIDDEN,
                                /*rule_id*/0,
                                /*score_delta*/ lcf->illegal_method_score);
        return WAF_RC_BLOCK;
    }
    return WAF_RC_CONTINUE;
}
```

- handler 使用 STAGE 宏（不做 flush）
```c
WAF_STAGE(ctx, waf_stage_ip_allow(r, mcf, lcf, ctx));
WAF_STAGE(ctx, waf_stage_ip_deny(r, mcf, lcf, ctx));
WAF_STAGE(ctx, waf_stage_reputation_base_add(r, mcf, lcf, ctx));
WAF_STAGE(ctx, waf_stage_uri_allow(r, mcf, lcf, ctx));
WAF_STAGE(ctx, waf_stage_detect_bundle(r, mcf, lcf, ctx)); // 各类规则（SQLi/XSS/…）
waf_action_finalize_allow(r, mcf, lcf, ctx);
return NGX_DECLINED;
```

- 说明
  - 若前面任何阶段 `waf_enforce_block/bypass` 已 final flush，`log_flushed`=1；尾部 `waf_log_flush_final` 会因去重保护而不重复落盘。

---

#### 9. 头文件组织与 include 习惯

- 头/源同名：`ngx_http_waf_action.[ch]`、`ngx_http_waf_log.[ch]`、`ngx_http_waf_dynamic_block.[ch]`、`ngx_http_waf_compiler.[ch]`、`ngx_http_waf_utils.[ch]`。
- 额外宏头：`src/include/ngx_http_waf_stage.h`（仅放 STAGE 宏与 `waf_rc_e` 定义/引用），价值：
  - 让 module 层最少依赖、最干净；方便统一升级早退策略；避免循环包含。
- 新增公共类型头：`src/include/ngx_http_waf_types.h`（放置 `waf_rc_e`、`waf_final_action_e` 等公共枚举），避免在多文件重复定义，降低耦合。
- include 方式遵循文档：构建脚本注入 `-I$ngx_addon_dir/src/include`，代码里使用 `"ngx_http_waf_*.h"`。

---

#### 10. 日志分类、级别与策略（与文档一致）

- 区分两类日志：
  - 运维日志（control-plane）：发生在解析/合并/编译/加载阶段，通过 Nginx `error_log` 输出，带固定前缀 `waf:`，用于运维与 CI/CD（含 dry-run `nginx -t -q`）。
  - 请求日志（data-plane）：一次请求一行 JSONL（`waf_json_log`），由 action/log 层在运行期聚合与落盘，记录安全事件与最终裁决。

- 请求日志级别集合：`off|debug|info|alert`。
- 请求日志落盘策略：
  - `finalAction=BLOCK`：至少 `alert`，必落盘。
  - `finalAction=BYPASS|ALLOW`：按 `waf_json_log_level` 阈值决定是否落盘。
- 运维日志用法：
  - 解析/合并期输出 `waf:` 前缀摘要与告警（例如重复规则策略、编译错误位置、final_doc 调试开关）。
  - CI/控制台通过 `nginx -t -q | grep -E "^waf:"` 采集并展示；不进入请求日志文件。

---

#### 10.1 `final_action=None` 的意义与 ALLOW 落盘策略

- 语义定义：
  - `WAF_FINAL_NONE` 表示“本请求未发生决定性动作”（既未 BLOCK、也未 BYPASS）。
  - 该状态通常贯穿整个流水线，直到管线尾部由 `waf_action_finalize_allow(...)` 做最终判定是否以 `ALLOW` 形式写出。

- 何时写出 ALLOW：
  - BLOCK/BYPASS 情况已在 action 内提前落盘（并置 `ctx->final_action`，`ctx->log_flushed=1`），与 `NONE` 无关。
  - 当尾部调用 `waf_action_finalize_allow(r,...)` 时，若 `ctx->final_action==WAF_FINAL_NONE` 且尚未落盘：
    - 若本次请求聚合的 `events` 数量为 0（无任何规则/信誉/ban/bypass/base_access 事件），则不落盘（避免噪音）。
    - 若 `events>0`，则视为 `ALLOW` 候选，按阈值 `waf_json_log_level` 判定：
      - `off`：不落盘。
      - `alert`：仍不落盘（仅 BLOCK 必落盘提升至 `alert`）。
      - `info|debug`：落盘一行 `ALLOW`（含聚合事件，便于事后分析）。

- 判定逻辑（概要）：
  - `if (ctx->log_flushed) return;`
  - `if (ctx->final_action==BLOCK||BYPASS)`：已提前处理；此处直接返回。
  - `/* NONE 路径 */`
    - `if (events_count==0) return; /* 空事件 ALLOW 不落盘 */`
    - `if (waf_json_log_level in {info,debug}) write_jsonl_with_finalAction("ALLOW"); else return;`

- 设计动机：
  - `final_action=None` 使“无事件/仅通过”的请求默认不写日志，显著降低日志体量；
  - 同时保留“有事件但未触发执法”的分析线索（在 `info|debug` 打开时），便于回溯与规则调参；
  - 与“BLOCK 必落盘、BYPASS 受阈值”的既有策略一致且互斥，不引入歧义。

注：如需在生产环境对“空事件 ALLOW”也进行抽样记录，可后续在 `main_conf` 增加可选项（例如 `waf_json_log_allow_empty on|off|sample(N)`），本版默认 `off`。

---

#### 11. 里程碑对齐（摘）

- M2.5 最小存根：`ngx_http_waf_action.[ch]`、`ngx_http_waf_log.[ch]`、`ngx_http_waf_dynamic_block.[ch]` 接口冻结；BLOCK 路径可在 error_log 打 JSON 摘要（或直接 JSONL）。
- M4：ACCESS 管线 + 请求体三段式；`WAF_STAGE` 宏替换散落 if；尾部 `waf_log_flush_final`。
- M5：动态信誉落地（评分/阈值/封禁），打通 action。

---

### 指令支持 Roadmap（v2.0 运维面）

- [x] `waf_jsons_dir`（MAIN）
- [x] `waf_rules_json`（HTTP/SRV/LOC，可覆盖）
- [x] `waf_json_extends_max_depth`（HTTP/SRV/LOC，loc 覆盖）
- [x] `waf_shm_zone <name> <size>`（MAIN）
- [x] `waf_json_log <path>`（MAIN）
- [x] `waf_json_log_level debug|info|alert|error|off`（MAIN）
- [ ] `waf on|off`（HTTP/SRV/LOC，loc 可覆盖；off 完全旁路）
- [ ] `waf_default_action BLOCK|LOG`（MAIN）
- [ ] `waf_trust_xff on|off`（MAIN）
- [ ] `waf_dynamic_block_enable on|off`（MAIN）
- [ ] `waf_dynamic_block_score_threshold <num>`（MAIN）
- [ ] `waf_dynamic_block_duration <time>`（MAIN）
- [ ] `waf_dynamic_block_window_size <time>`（MAIN）
- [ ] `waf_json_log_allow_empty on|off|sample(N)`（MAIN，v2.1 规划，目前版本不考虑）
- [ ] `waf_debug_final_doc on|off`（MAIN，v2.1 规划，目前版本不考虑）

规范详见：`docs/waf-directives-spec-v2.0.md`

---

### 可直接落地的最小代码片段

- `src/include/ngx_http_waf_stage.h`（已给）
- `src/core/ngx_http_waf_action.h`（接口）
```c
#ifndef _NGX_HTTP_WAF_ACTION_H_INCLUDED_
#define _NGX_HTTP_WAF_ACTION_H_INCLUDED_

#include <ngx_http.h>
#include "ngx_http_waf_types.h"   // 放 waf_rc_e / waf_final_action_e / ctx 声明等（可并入任一公共头）

waf_rc_e waf_enforce(ngx_http_request_t* r,
                    ngx_http_waf_main_conf_t* mcf,
                    ngx_http_waf_loc_conf_t*  lcf,
                    ngx_http_waf_ctx_t*       ctx,
                    int intent_block_1_log_0_bypass_2,
                    ngx_int_t http_status_if_block,
                    ngx_uint_t rule_id_or_0,
                    ngx_uint_t score_delta);

static inline waf_rc_e
waf_enforce_block(ngx_http_request_t* r, ngx_http_waf_main_conf_t* mcf,
                  ngx_http_waf_loc_conf_t* lcf, ngx_http_waf_ctx_t* ctx,
                  ngx_int_t http_status, ngx_uint_t rule_id_or_0, ngx_uint_t score_delta);

static inline waf_rc_e
waf_enforce_bypass(ngx_http_request_t* r, ngx_http_waf_main_conf_t* mcf,
                   ngx_http_waf_loc_conf_t* lcf, ngx_http_waf_ctx_t* ctx,
                   ngx_uint_t rule_id_or_0);

waf_rc_e waf_enforce_base_add(ngx_http_request_t* r,
                              ngx_http_waf_main_conf_t* mcf,
                              ngx_http_waf_loc_conf_t*  lcf,
                              ngx_http_waf_ctx_t*       ctx,
                              ngx_uint_t score_delta);

#endif
```

- `src/core/ngx_http_waf_log.h`（接口）
```c
#ifndef _NGX_HTTP_WAF_LOG_H_INCLUDED_
#define _NGX_HTTP_WAF_LOG_H_INCLUDED_

#include <ngx_http.h>
#include "ngx_http_waf_types.h"

void waf_log_init_ctx(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx);

void waf_log_append_rule_event(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx,
                               ngx_uint_t rule_id, const char* target_tag,
                               ngx_uint_t score_delta, ngx_uint_t total_score,
                               const ngx_str_t* matched_pattern, ngx_uint_t pattern_index,
                               ngx_flag_t negate,
                               const char* intent_str);

void waf_log_append_reputation_event(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx,
                                     ngx_int_t delta, ngx_uint_t total_score,
                                     const char* reason_tag);

void waf_log_flush_final(ngx_http_request_t* r,
                         ngx_http_waf_main_conf_t* mcf,
                         ngx_http_waf_loc_conf_t*  lcf,
                         ngx_http_waf_ctx_t*       ctx,
                         const char* final_action_hint);

#endif
```

说明：
- `ngx_http_waf_types.h` 可作为公共类型头（`waf_rc_e`、`waf_final_action_e`、`ngx_http_waf_ctx_t` 前置声明等），与“头/源同名”不冲突，价值是解耦模块间公共枚举/ctx 声明，防循环包含。

---

### 落地建议（小步快跑）

- 新增头文件：
  - `/home/william/myNginxWorkspace/nginx-http-waf-module-v2/src/include/ngx_http_waf_stage.h`
  - `/home/william/myNginxWorkspace/nginx-http-waf-module-v2/src/core/ngx_http_waf_action.h`
  - 若需要：`ngx_http_waf_types.h`
- 在 `config` 里确保 `-I$ngx_addon_dir/src/include`，并把新 `.c` 加入 `NGX_ADDON_SRCS`。
- 修改 `access_handler`：
  - 用 `WAF_STAGE(ctx, ...)` 替换散落的 `if (rc != NGX_DECLINED) return rc;`
  - 尾部显式调用 `waf_action_finalize_allow(r, mcf, lcf, ctx)`。
- 在 action 的 BLOCK/BYPASS 路径内做最终落盘（并置 `ctx->log_flushed=1`），避免尾部重复落盘。

---

### 编码风格与格式化

- 统一缩进：2 空格；不使用制表符（与 `.clang-format` 一致：`IndentWidth: 2`, `UseTab: Never`）。
- 行宽：80 列；自动换行由 clang-format 控制（`ColumnLimit: 80`）。
- 工具与配置：
  - 配置文件：`/home/william/myNginxWorkspace/nginx-http-waf-module-v2/.clang-format`
  - 批量格式化脚本：`/home/william/myNginxWorkspace/nginx-http-waf-module-v2/format_code.sh`（忽略 `third_party/`）
- 使用建议：
  - 开发提交前统一格式：
    ```bash
    bash /home/william/myNginxWorkspace/nginx-http-waf-module-v2/format_code.sh
    ```
  - CI 可增加“格式检查/自动格式化”步骤，确保风格一致性。

---

### 关于你提到的两个细节

- “STAGE 宏的 flush 可选项要去掉吗？”
  - 是。已在本设计中彻底移除；flush 完全由 action 层（BLOCK/BYPASS）与管线尾（ALLOW）掌控。
- “WAF_RC_ASYNC 用得上吗？”
  - 当前按 v1 的读体模型，通常不由阶段返回；保留仅为未来阶段内部发起异步准备，不使用也不影响设计。

---

- 已对齐文档：整体分层/流水线/日志与动态信誉接口，与 `refactor-plan-v2.md`、`waf-json-spec-v2.0-simplified.md`、`milestones.md` 一致。
- 若同意，我下一步可在 v2 目录按上述文件名落地最小头文件与空实现骨架，配合 `config` 更新确保可编译，然后逐段把 `access_handler` 改用 `WAF_STAGE`。