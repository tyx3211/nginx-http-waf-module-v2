### 先明确两点（你刚提到的关键决定）
- STAGE 宏里不再做任何 flush，只做“根据阶段返回枚举 → 映射成 Nginx rc 的早退”。是否落盘、何时落盘，一律由 action 层函数内部决定（BLOCK/BYPASS 立即落盘）；管线尾部的“FINAL flush”由 handler 显式调用 action 层的 `waf_action_finalize_allow(...)` 完成。
- `final_action/final_status` 仅由 action 层在 BLOCK/BYPASS 时写入；module 层完全不关心它们，且不需要 unset 语义（默认 0 即可）。

---

### 接口统一化调整（新增）

- 统一采用“waf_enforce_*”族函数，取消单独的 `waf_add_score`；将“基础访问加分”改为可导致拦截的执法接口：`waf_enforce_base_add(...)`（返回 `waf_rc_e`）。
- 包装器与入口：

```c
// 统一入口（底座），由各包装器调用；支持携带 scoreDelta
ngx_int_t waf_enforce(ngx_http_request_t* r,
                      ngx_http_waf_main_conf_t* mcf,
                      ngx_http_waf_loc_conf_t*  lcf,
                      ngx_http_waf_ctx_t*       ctx,
                      /* intent */    int intent_block_1_log_0_bypass_2,
                      /* http */      ngx_int_t http_status_if_block,
                      /* rule id */   ngx_uint_t rule_id_or_0,
                      /* score */     ngx_uint_t score_delta);

// 语义包装：规则/策略触发 BLOCK（可带分数）
static inline ngx_int_t
waf_enforce_block(ngx_http_request_t* r, ngx_http_waf_main_conf_t* mcf,
                  ngx_http_waf_loc_conf_t* lcf, ngx_http_waf_ctx_t* ctx,
                  ngx_int_t http_status, ngx_uint_t rule_id_or_0, ngx_uint_t score_delta);

// 语义包装：仅记录事件（可带分数），不拦截
static inline ngx_int_t
waf_enforce_log(ngx_http_request_t* r, ngx_http_waf_main_conf_t* mcf,
                ngx_http_waf_loc_conf_t* lcf, ngx_http_waf_ctx_t* ctx,
                ngx_uint_t rule_id_or_0, ngx_uint_t score_delta);

// 语义包装：本次请求软放行并绕过后续阶段（立即 FINAL flush）
static inline ngx_int_t
waf_enforce_bypass(ngx_http_request_t* r, ngx_http_waf_main_conf_t* mcf,
                   ngx_http_waf_loc_conf_t* lcf, ngx_http_waf_ctx_t* ctx,
                   ngx_uint_t rule_id_or_0);

// 基础访问加分（可触发封禁）：返回 waf_rc_e 以便被 STAGE 宏统一处理
waf_rc_e waf_enforce_base_add(ngx_http_request_t* r,
                              ngx_http_waf_main_conf_t* mcf,
                              ngx_http_waf_loc_conf_t*  lcf,
                              ngx_http_waf_ctx_t*       ctx,
                              ngx_uint_t score_delta);
```

- 约定：
  - `waf_enforce_*` 内部负责：聚合意图→（可选）加分→复检封禁→写入 `ctx->final_*`→记录事件→在 BLOCK/BYPASS 时立即 `waf_log_flush_final(...)`；LOG/base_add 不落盘。
  - 阶段函数只需返回 `waf_rc_e`（对 `base_add`）或在调用 `waf_enforce_block/bypass/log` 后对应返回 `WAF_RC_BLOCK/BYPASS/CONTINUE`；STAGE 宏完成早退映射。

### 详细设计书（对齐 `refactor-plan-v2.md` 与 `waf-json-spec-v2.0-simplified.md`）

#### 1. 模块划分与职责边界

- module 层（`src/module/`）
  - 入口/指令/merge；ACCESS 阶段“5 段流水线”执行；请求体异步挂载与回调推进；只调用 action API；不接触动态信誉与日志细节（尾部 FINAL 也通过 action 完成）。
- action 层（`src/core/ngx_http_waf_action.[ch]`）
  - 统一动作出口：BLOCK/BYPASS/LOG 与评分的归并；设置 `ctx->final_action/final_status`；记录日志事件；对 BLOCK/BYPASS 立即 flush；对 LOG/加分不 flush。
- 动态信誉层（`src/core/ngx_http_waf_dynamic_block.[ch]`）
  - 共享内存（rbtree+queue+slab）；评分窗口/阈值/封禁与过期；提供 `waf_dyn_*` API，被 action 调用。
- 日志层（`src/core/ngx_http_waf_log.[ch]`）
  - 请求内事件聚合；`waf_log_append_*`；`waf_log_flush_final` 输出一行 JSONL；级别：off|debug|info|alert（支持 audit→alert 别名）；含去重/只 flush 一次的保护。
- 规则 JSON/编译层（`src/json/ngx_http_waf_json.[ch]`、`src/core/ngx_http_waf_compiler.[ch]`）
  - 解析/extends/禁用/去重；生成只读快照（分桶/预编译 regex/CIDR）；loc_conf 挂载。
- 工具层（`src/core/ngx_http_waf_utils.[ch]`）
  - XFF/IPv4、URI decode 等通用工具。

依赖方向（强约束）：module → action → {dynamic, log}；module 不直接依赖 dynamic/log（包括 FINAL 也通过 action 的 finalize 包装调用日志）。

---

#### 2. 运行时上下文与关键字段

- `ngx_http_waf_ctx_t`（摘取关键字段）
  - `client_ip_addr:uint32`, `client_ip_str:ngx_str_t`
  - `total_score:uint32`（可选快照）
  - `final_action:waf_final_action_e`（0/none，1/block，2/bypass）
  - `final_status:ngx_int_t`（仅 BLOCK/BYPASS 写入，默认 0）
  - `log_doc/*events*/`（日志聚合句柄）
  - `log_flushed:ngx_flag_t`（是否已最终落盘，防重）
  - 说明：`final_*` 只由 action 写；module 不读不写（除末尾判断是否需要 FINAL flush，可读 `log_flushed`）。

---

#### 3. 阶段返回枚举与 STAGE 宏

- 返回枚举（轻量最小集）
```c
typedef enum {
    WAF_RC_CONTINUE = 0,   // 继续后续阶段
    WAF_RC_BYPASS,         // 本模块后续阶段不再执行（外层映射 NGX_DECLINED）
    WAF_RC_BLOCK,          // 阻断（外层返回 HTTP_xxx）
    WAF_RC_ASYNC,          // 预留：阶段内部进入异步（外层映射 NGX_DONE）；当前 v2 初版通常不用
    WAF_RC_ERROR           // 内部错误（外层返回 500）
} waf_rc_e;

typedef enum {
    WAF_FINAL_NONE  = 0,
    WAF_FINAL_BLOCK = 1,
    WAF_FINAL_BYPASS= 2,
} waf_final_action_e;
```

- STAGE 宏（仅用于编排层：handler/请求体回调；不在阶段函数内部使用）
```c
// src/include/ngx_http_waf_stage.h
#ifndef _NGX_HTTP_WAF_STAGE_H_INCLUDED_
#define _NGX_HTTP_WAF_STAGE_H_INCLUDED_

#include "ngx_http_waf_action.h"

#define WAF_STAGE(ctx, CALL)                                                    \
    do {                                                                        \
        waf_rc_e _waf_rc = (CALL);                                              \
        if (_waf_rc == WAF_RC_ASYNC)   { return NGX_DONE; }                     \
        if (_waf_rc == WAF_RC_BLOCK)   {                                        \
            return (ctx)->final_status > 0 ? (ctx)->final_status                \
                                           : NGX_HTTP_FORBIDDEN;                \
        }                                                                        \
        if (_waf_rc == WAF_RC_BYPASS)  { return NGX_DECLINED; }                 \
        if (_waf_rc == WAF_RC_ERROR)   { return NGX_HTTP_INTERNAL_SERVER_ERROR; }\
    } while (0)

#endif
```
- 价值说明（单独头 `ngx_http_waf_stage.h`）：
  - 只依赖 `waf_rc_e` 与 `ctx->final_status`，避免把日志/动态信誉等细节拉进 module 层。
  - 让 module 层的 handler/回调代码高度简洁一致，便于审阅与重构。

---

#### 4. action 层设计（统一动作出口）

- 约定
  - 任意阶段函数如需“执法或软放行”，必须调用 action API；仅返回 `waf_rc_e` 用于 STAGE 宏早退。
  - BLOCK/BYPASS 在 action 内立即做“最终落盘”（final flush），并设置 `ctx->final_action/final_status` 与 `log_flushed=1`，避免 module 再 flush。
  - 纯 LOG 或 评分不落盘，仅聚合事件；最终在管线尾部由 module 调用 action 的 `waf_action_finalize_allow(...)` 做一次 FINAL（若未早退）。

- API（头/源同名：`ngx_http_waf_action.[ch]`）
```c
// 统一入口（底座），供包装器调用
ngx_int_t waf_enforce(ngx_http_request_t* r,
                      ngx_http_waf_main_conf_t* mcf,
                      ngx_http_waf_loc_conf_t*  lcf,
                      ngx_http_waf_ctx_t*       ctx,
                      /* intent */    int intent_block_1_log_0_bypass_2,
                      /* http */      ngx_int_t http_status_if_block,
                      /* rule id */   ngx_uint_t rule_id_or_0,
                      /* score */     ngx_uint_t score_delta);

// 轻量包装（建议在阶段里优先使用）
static inline ngx_int_t
waf_enforce_block(ngx_http_request_t* r, ngx_http_waf_main_conf_t* mcf,
                  ngx_http_waf_loc_conf_t* lcf, ngx_http_waf_ctx_t* ctx,
                  ngx_int_t http_status, ngx_uint_t rule_id_or_0, ngx_uint_t score_delta) {
    return waf_enforce(r, mcf, lcf, ctx, /*BLOCK*/1, http_status, rule_id_or_0, score_delta);
}

static inline ngx_int_t
waf_enforce_bypass(ngx_http_request_t* r, ngx_http_waf_main_conf_t* mcf,
                   ngx_http_waf_loc_conf_t* lcf, ngx_http_waf_ctx_t* ctx,
                   ngx_uint_t rule_id_or_0) {
    return waf_enforce(r, mcf, lcf, ctx, /*BYPASS*/2, NGX_DECLINED, rule_id_or_0, 0);
}

// 仅加分（无执法），内部调用 dynamic 与日志事件聚合，不落盘
void waf_add_score(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx, ngx_uint_t delta);

// 尾部 FINAL（ALLOW）统一出口，由 module 在 handler/回调尾部调用
void waf_action_finalize_allow(ngx_http_request_t* r,
                               ngx_http_waf_main_conf_t* mcf,
                               ngx_http_waf_loc_conf_t*  lcf,
                               ngx_http_waf_ctx_t*       ctx);
```

- 行为细则
  - BLOCK 路径：
    - 先 `waf_add_score`（若传入 score_delta>0）→ `waf_dyn_score_add` → 复检是否达阈值（可直接 BAN）；
    - 设置 `ctx->final_action=BLOCK` 与 `ctx->final_status=http_status`；
    - `waf_log_append_event`（含 ruleId/scoreDelta/totalScore/target）；随后 `waf_log_flush_final(r,mcf,lcf,ctx,"BLOCK")`（仅一次）。
    - 返回 `NGX_OK` 给阶段函数；阶段函数返回 `WAF_RC_BLOCK` 给 STAGE 宏完成早退。
  - BYPASS 路径：
    - 设置 `ctx->final_action=BYPASS`；记录事件；立即 `waf_log_flush_final(...,"BYPASS")`（仅一次）；
    - 返回 `NGX_OK`；阶段函数返回 `WAF_RC_BYPASS`。
  - LOG/评分：
    - 聚合事件；不 flush；阶段函数返回 `WAF_RC_CONTINUE`。

- 幂等保护
  - `waf_log_flush_final` 内部检查 `ctx->log_flushed`；若已落盘则直接返回，避免多处触发导致重复行。

---

#### 5. 日志层设计（一次请求一行 JSONL）

- 接口（`ngx_http_waf_log.[ch]`）
```c
void waf_log_init_ctx(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx);

void waf_log_append_rule_event(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx,
                               ngx_uint_t rule_id, const char* target_tag,
                               ngx_uint_t score_delta, ngx_uint_t total_score,
                               const ngx_str_t* matched_pattern, ngx_uint_t pattern_index,
                               const char* intent_str /* "BLOCK"|"LOG"|"BYPASS" */);

void waf_log_append_reputation_event(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx,
                                     ngx_int_t delta, ngx_uint_t total_score,
                                     const char* reason_tag);

void waf_log_flush_final(ngx_http_request_t* r,
                         ngx_http_waf_main_conf_t* mcf,
                         ngx_http_waf_loc_conf_t*  lcf,
                         ngx_http_waf_ctx_t*       ctx,
                         const char* final_action_hint /* "BLOCK"|"BYPASS"|"ALLOW"|NULL */);
```

- 级别与落盘策略
  - 级别：`off|debug|info|alert`（支持 `audit` 别名映射至 `alert`）。
  - BLOCK：将 `effective_level` 至少提升到 `alert`，必落盘。
  - BYPASS/ALLOW：按阈值（`waf_json_log_level`）决定是否落盘。
  - 只落盘一次（`ctx->log_flushed`）。

- 输出
  - JSONL 一行（包含 `finalAction`、`finalActionType` 与 `status`）；`error_log` 可选摘要（非强制）。

##### JSONL 结构（统一草案）

```json
{
  "time": "2025-09-14T12:34:56.789Z",
  "clientIp": "1.2.3.4",
  "method": "POST",
  "uri": "/login?x=1",
  "events": [
    { "type": "reputation", "scoreDelta": 1,  "totalScore": 1,  "ts": 1699999999000, "reason": "base_access" },
    { "type": "rule",       "ruleId": 200010, "intent": "BLOCK", "scoreDelta": 20, "totalScore": 21,
      "matchedPattern": "(?i)union\\s+select", "patternIndex": 0, "target": "ALL_PARAMS", "ts": 1699999999050 },
    { "type": "ban",        "ts": 1699999999051, "window": 60000 }
  ],
  "finalAction": "BLOCK",
  "finalActionType": "BLOCK_BY_RULE",
  "status": 403
}
```

- 取值约定：
  - `events[].type`：`reputation|rule|ban|bypass|base_access`。
  - `finalActionType`：`BLOCK_BY_RULE|BLOCK_BY_REPUTATION|BLOCK_BY_IP_BLACKLIST|BYPASS_BY_IP_WHITELIST|BYPASS_BY_URI_WHITELIST|ALLOW`。
  - `finalAction`：`BLOCK|BYPASS|ALLOW`。
  - 级别：根据 `finalAction` 自动提升（`BLOCK→alert`），其余受 `waf_json_log_level` 控制。

---

#### 6. 动态信誉层（M5 并行推进）

- 接口（`ngx_http_waf_dynamic_block.[ch]`）
```c
void      waf_dyn_score_add(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx, ngx_int_t delta);
ngx_flag_t waf_dyn_is_banned(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx);
void      waf_dyn_ban(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx, ngx_msec_t duration);
```

- 设计要点
  - 共享内存：`ngx_rbtree_t + ngx_queue_t(LRU)` + `ngx_slab_pool` + `ngx_shmtx_t`。
  - 窗口滑动、过期、阈值命中执法；必要时分片多 zone 降竞争。

---

#### 7. 执行流水与异步体处理（与 v1 一致）

- 5 段流水（参照 `refactor-plan-v2.md`）
  1) IP 允许（硬放行，BYPASS 短路）  
  2) IP 拒绝（硬拒绝，BLOCK 短路）  
  3) 信誉评分/封禁（基础访问加分 → BAN 复检 → 可能 BLOCK）  
  4) URI 允许（软放行，BYPASS 短路）  
  5) 检测段（SQLi/XSS/UA/非法方法/Cookie/CSRF…，可带 score → 统一动作出口）

- 同步/异步分支
  - GET/HEAD 或 `content_length_n == 0`：直接跑检测段（BODY 视为空串），跑完尾部做 FINAL flush（若未早退）。
  - 其他：`ngx_http_read_client_request_body(r, post_read_body_handler)`；返回 `NGX_DONE`。回调中：
    - 收集请求体（合并内存/文件缓冲；按 `x-www-form-urlencoded` 解码）；
    - 跑整个“检测段”（含规则/评分/执法），使用 `WAF_STAGE` 宏早退；
    - 若未早退，`waf_log_flush_final(...,"ALLOW")`；推进 `r->phase_handler++; ngx_http_core_run_phases(r)`。

- 关于 `WAF_RC_ASYNC`
  - 当前模式下通常不由阶段函数返回（异步由 module 层统一触发/接管）；保留该枚举为未来阶段内部发起异步（如子请求/挑战）时使用。

---

#### 8. 阶段函数编写范式（无编排层，仅返回枚举）

- 示例（非法方法）
```c
static waf_rc_e
waf_stage_illegal_method(ngx_http_request_t* r,
                         ngx_http_waf_main_conf_t* mcf,
                         ngx_http_waf_loc_conf_t*  lcf,
                         ngx_http_waf_ctx_t*       ctx)
{
    if (!lcf->default_illegal_method_defense_enabled) return WAF_RC_CONTINUE;

    if (/* 命中非法方法 */) {
        // 评分 + 执法（立即 final flush）
        (void)waf_enforce_block(r, mcf, lcf, ctx,
                                NGX_HTTP_FORBIDDEN,
                                /*rule_id*/0,
                                /*score_delta*/ lcf->illegal_method_score);
        return WAF_RC_BLOCK;
    }
    return WAF_RC_CONTINUE;
}
```

- handler 使用 STAGE 宏（不做 flush）
```c
WAF_STAGE(ctx, waf_stage_ip_allow(r, mcf, lcf, ctx));
WAF_STAGE(ctx, waf_stage_ip_deny(r, mcf, lcf, ctx));
WAF_STAGE(ctx, waf_stage_reputation_base_add(r, mcf, lcf, ctx));
WAF_STAGE(ctx, waf_stage_uri_allow(r, mcf, lcf, ctx));
WAF_STAGE(ctx, waf_stage_detect_bundle(r, mcf, lcf, ctx)); // 各类规则（SQLi/XSS/…）
waf_action_finalize_allow(r, mcf, lcf, ctx);
return NGX_DECLINED;
```

- 说明
  - 若前面任何阶段 `waf_enforce_block/bypass` 已 final flush，`log_flushed`=1；尾部 `waf_log_flush_final` 会因去重保护而不重复落盘。

---

#### 9. 头文件组织与 include 习惯

- 头/源同名：`ngx_http_waf_action.[ch]`、`ngx_http_waf_log.[ch]`、`ngx_http_waf_dynamic_block.[ch]`、`ngx_http_waf_compiler.[ch]`、`ngx_http_waf_utils.[ch]`。
- 额外宏头：`src/include/ngx_http_waf_stage.h`（仅放 STAGE 宏与 `waf_rc_e` 定义/引用），价值：
  - 让 module 层最少依赖、最干净；方便统一升级早退策略；避免循环包含。
- 新增公共类型头：`src/include/ngx_http_waf_types.h`（放置 `waf_rc_e`、`waf_final_action_e` 等公共枚举），避免在多文件重复定义，降低耦合。
- include 方式遵循文档：构建脚本注入 `-I$ngx_addon_dir/src/include`，代码里使用 `"ngx_http_waf_*.h"`。

---

#### 10. 日志级别与策略（与文档一致）

- 级别集合：`off|debug|info|alert`，`audit`→`alert` 别名。
- BLOCK：至少 `alert`，必落盘；BYPASS/ALLOW：按阈值。
- 控制台/CI：仍可从 `error_log` 提取 `waf:` 前缀摘要；JSONL 为结构化面向控制台/分析。

---

#### 11. 里程碑对齐（摘）

- M2.5 最小存根：`ngx_http_waf_action.[ch]`、`ngx_http_waf_log.[ch]`、`ngx_http_waf_dynamic_block.[ch]` 接口冻结；BLOCK 路径可在 error_log 打 JSON 摘要（或直接 JSONL）。
- M4：ACCESS 管线 + 请求体三段式；`WAF_STAGE` 宏替换散落 if；尾部 `waf_log_flush_final`。
- M5：动态信誉落地（评分/阈值/封禁），打通 action。

---

### 可直接落地的最小代码片段

- `src/include/ngx_http_waf_stage.h`（已给）
- `src/core/ngx_http_waf_action.h`（接口）
```c
#ifndef _NGX_HTTP_WAF_ACTION_H_INCLUDED_
#define _NGX_HTTP_WAF_ACTION_H_INCLUDED_

#include <ngx_http.h>
#include "ngx_http_waf_types.h"   // 放 waf_rc_e / waf_final_action_e / ctx 声明等（可并入任一公共头）

ngx_int_t waf_enforce(ngx_http_request_t* r,
                      ngx_http_waf_main_conf_t* mcf,
                      ngx_http_waf_loc_conf_t*  lcf,
                      ngx_http_waf_ctx_t*       ctx,
                      int intent_block_1_log_0_bypass_2,
                      ngx_int_t http_status_if_block,
                      ngx_uint_t rule_id_or_0,
                      ngx_uint_t score_delta);

static inline ngx_int_t
waf_enforce_block(ngx_http_request_t* r, ngx_http_waf_main_conf_t* mcf,
                  ngx_http_waf_loc_conf_t* lcf, ngx_http_waf_ctx_t* ctx,
                  ngx_int_t http_status, ngx_uint_t rule_id_or_0, ngx_uint_t score_delta);

static inline ngx_int_t
waf_enforce_bypass(ngx_http_request_t* r, ngx_http_waf_main_conf_t* mcf,
                   ngx_http_waf_loc_conf_t* lcf, ngx_http_waf_ctx_t* ctx,
                   ngx_uint_t rule_id_or_0);

void waf_add_score(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx, ngx_uint_t delta);

#endif
```

- `src/core/ngx_http_waf_log.h`（接口）
```c
#ifndef _NGX_HTTP_WAF_LOG_H_INCLUDED_
#define _NGX_HTTP_WAF_LOG_H_INCLUDED_

#include <ngx_http.h>
#include "ngx_http_waf_types.h"

void waf_log_init_ctx(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx);

void waf_log_append_rule_event(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx,
                               ngx_uint_t rule_id, const char* target_tag,
                               ngx_uint_t score_delta, ngx_uint_t total_score,
                               const ngx_str_t* matched_pattern, ngx_uint_t pattern_index,
                               const char* intent_str);

void waf_log_append_reputation_event(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx,
                                     ngx_int_t delta, ngx_uint_t total_score,
                                     const char* reason_tag);

void waf_log_flush_final(ngx_http_request_t* r,
                         ngx_http_waf_main_conf_t* mcf,
                         ngx_http_waf_loc_conf_t*  lcf,
                         ngx_http_waf_ctx_t*       ctx,
                         const char* final_action_hint);

#endif
```

说明：
- `ngx_http_waf_types.h` 可作为公共类型头（`waf_rc_e`、`waf_final_action_e`、`ngx_http_waf_ctx_t` 前置声明等），与“头/源同名”不冲突，价值是解耦模块间公共枚举/ctx 声明，防循环包含。

---

### 落地建议（小步快跑）

- 新增头文件：
  - `/home/william/myNginxWorkspace/nginx-http-waf-module-v2/src/include/ngx_http_waf_stage.h`
  - `/home/william/myNginxWorkspace/nginx-http-waf-module-v2/src/core/ngx_http_waf_action.h`
  - 若需要：`ngx_http_waf_types.h`
- 在 `config` 里确保 `-I$ngx_addon_dir/src/include`，并把新 `.c` 加入 `NGX_ADDON_SRCS`。
- 修改 `access_handler`：
  - 用 `WAF_STAGE(ctx, ...)` 替换散落的 `if (rc != NGX_DECLINED) return rc;`
  - 尾部显式调用 `waf_action_finalize_allow(r, mcf, lcf, ctx)`。
- 在 action 的 BLOCK/BYPASS 路径内做最终落盘（并置 `ctx->log_flushed=1`），避免尾部重复落盘。

---

### 关于你提到的两个细节

- “STAGE 宏的 flush 可选项要去掉吗？”
  - 是。已在本设计中彻底移除；flush 完全由 action 层（BLOCK/BYPASS）与管线尾（ALLOW）掌控。
- “WAF_RC_ASYNC 用得上吗？”
  - 当前按 v1 的读体模型，通常不由阶段返回；保留仅为未来阶段内部发起异步准备，不使用也不影响设计。

---

- 已对齐文档：整体分层/流水线/日志与动态信誉接口，与 `refactor-plan-v2.md`、`waf-json-spec-v2.0-simplified.md`、`milestones.md` 一致。
- 若同意，我下一步可在 v2 目录按上述文件名落地最小头文件与空实现骨架，配合 `config` 更新确保可编译，然后逐段把 `access_handler` 改用 `WAF_STAGE`。