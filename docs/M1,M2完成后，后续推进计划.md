### 目标与边界
- 本轮只做计划与设计，不改代码。输出可作为 M3/M4 的实现蓝本与评审依据。
- 结论先行：M3、M4 都依赖“动作模块”和“日志模块”的最小可用存根；异步请求体按 v1 思路实现，结合更稳的回调推进与零分配目标。

### 关键决策（建议采纳）
- 全局统一动作默认策略（BLOCK/LOG）以及 JSONL 日志开关/级别/路径，均用 Nginx 指令配置，而不是 JSON 规则工件：
  - 原因：它们是运行时策略和运维层关注点（与规则数据面解耦），需要 `nginx -t` 与热重载友好，且支持 http/server/location 继承。
- 动作模块独立为 `src/core/ngx_http_waf_action.[ch]`；日志模块独立为 `src/core/ngx_http_waf_log.[ch]`，M3 先落最小接口与存根，M4 打通请求期全链路。
- 日志级别（配置级）建议采用：off | error | info | debug；请求态有效级别（effective_level）引入 none 用于“未记录”态，顺序为：none < debug < info < error < off（off 仅用于配置，不作为有效级别）。
- 两类日志接口并存（满足“溯源完整性”诉求）：
  - 完整性接口：事件一定写入本次请求的内存日志文档，并提升本请求的“整体日志级别”（不立即落盘，由最终 flush 判定是否写文件）。
  - 常规接口：只有事件级别 ≥ 配置级别时才写入本次请求的内存日志文档，同时提升整体级别。
  - Flush 时机：仅在“最终统一动作”处落盘（BLOCK 时强制落；放行路径由调用方在请求末尾声明“final”再落），否则不落地。
- 异步请求体处理：沿用 v1 的总体模型（异步读取 + 回调推进 + 三段式体收集），加强几处正确性/健壮性：
  - 严格使用 HTTP 状态码做 `finalize`；通过/放行时用相位推进（`r->phase_handler++; ngx_http_core_run_phases(r);`）。
  - 支持内存与文件缓冲共存；零分配/最少分配路径（短体/GET 直接走“空体快速通道”）。

---

## 动作模块设计（M3 引入存根，M4 完成实现）
- 位置：`src/core/ngx_http_waf_action.[ch]`
- 职责：聚合“事件意图”（规则或系统触发的 BLOCK/LOG/BYPASS）与“全局策略（BLOCK/LOG）”，统一计分与执法，统一落日志。
- 关键接口（与 `refactor-plan-v2.md` 对齐）：
```c
// 事件意图（由调用方给出）
typedef enum { WAF_INTENT_BLOCK, WAF_INTENT_LOG, WAF_INTENT_BYPASS } waf_intent_e;

// 统一动作出口
ngx_int_t waf_enforce(ngx_http_request_t* r,
                      ngx_http_waf_main_conf_t* mcf,
                      ngx_http_waf_loc_conf_t* lcf,
                      ngx_http_waf_ctx_t* ctx,
                      waf_intent_e intent,
                      int http_status,              // BLOCK 场景的状态码，如 403
                      uint32_t rule_id_or_0);       // 0 表示系统/信誉事件
```
- 行为要点
  - 计分路径（动态封禁）：当启用动态封禁且 `score>0`，先计分再复检封禁命中；命中即返回 `403`。
  - 统一动作决策：若全局策略为 BLOCK 且事件意图为 BLOCK → 实际拦截；若全局策略 LOG → 永不拦截。
  - 日志：动作函数负责附加事件日志（类型、ruleId、scoreDelta、totalScore、intent），并在“确定最终动作”时触发 flush（见日志模块）。
- M3 存根化：内部仅做“日志摘要 + 统一返回码”，计分/封禁可先记录 TODO；M4 再打通与共享内存的真实加分/封禁。

---

## 日志模块设计（M3 引入存根，M4 完成实现）
- 位置：`src/core/ngx_http_waf_log.[ch]`
- Nginx 指令（M3 引入）
  - `waf_json_log <path>|off;`（http 级；JSONL 输出路径）
  - `waf_json_log_level off|error|info|debug;`（http 级；最小写入级别）
- ctx 内部结构（请求态）
  - `yyjson_mut_doc* log_doc; yyjson_mut_val* events;`
  - `waf_log_level_e effective_level;`（本次请求的“整体日志级别”，默认 none）
  - `ngx_uint_t total_score;`、`final_action`、`final_status`
  - `uint8_t has_complete_events;`
- 事件模型（最小集）
  - `type`: reputation|rule|ban|bypass
  - `ruleId?`, `intent`, `scoreDelta?`, `totalScore`, `matchedPattern?`, `patternIndex?`, `target`, `ts`
- 接口最小集
```c
typedef enum { WAF_LOG_NONE=0, WAF_LOG_DEBUG=1, WAF_LOG_INFO=2, WAF_LOG_ERROR=3 } waf_log_level_e;

// 初始化（在请求首次进入 WAF 时调用一次）
void waf_log_init_request(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx);

// 完整性接口：事件一定写入本请求 log_doc，并将 effective_level = max(effective_level, level)
void waf_log_append_event_complete(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx,
                                   waf_log_level_e level,
                                   /* event fields... */);

// 常规接口：仅当 level >= 配置级别 时才写入，并提升 effective_level
void waf_log_append_event(ngx_http_request_t* r, ngx_http_waf_ctx_t* ctx,
                          waf_log_level_e level,
                          /* event fields... */);

// 最终落盘：仅在“最终动作”处调用；若 BLOCK，强制落并将 level 至少提升为 ERROR；
// 放行路径：调用方显式传入 final_action=LOG/BYPASS，若 effective_level >= 配置级别才落盘
void waf_log_flush(ngx_http_request_t* r,
                   ngx_http_waf_main_conf_t* mcf,
                   ngx_http_waf_loc_conf_t* lcf,
                   ngx_http_waf_ctx_t* ctx,
                   /* final_action, final_status ... */);
```
- 说明：配置级别 `off|error|info|debug` 存储在 `main_conf`；`WAF_LOG_NONE` 仅用于请求态的 `effective_level` 初始值（未记录）。当且仅当 `final_action=BLOCK` 时无视配置级别强制落盘；否则按 `effective_level >= 配置级别` 判定是否落盘。
- 级别与完整性策略
  - 完整性接口写入的 DEBUG 事件（如 baseAccessScore=1）会被保存在本次请求的内存文档中，即便当前配置级别为 INFO，也不会丢失；若最终动作升级为 BLOCK（ERROR），flush 时这类早期 DEBUG 事件会随整条日志一并落盘（保证溯源完整）。
  - 常规接口只在“事件级别 ≥ 配置级别”时写入内存文档，避免正常流量产生噪音。
  - Flush 判定：默认本请求处于“未记录”状态（effective_level=none）；只有当最终动作或累积事件将 effective_level 提升到 ≥ 配置级别时才落盘；BLOCK 场景强制落盘（并将 level 至少提升到 ERROR）。
  - BYPASS 视作放行终态，不强制落盘；但如 `effective_level >= 配置级别`，同样会在最后一次 action 时落盘（完整性接口累计的事件会被一并写出）。
- 输出
  - 单行 JSONL，O_APPEND 写文件；构建字符串在 flush 时一次性完成，避免中途反复格式化。

---

## M3 推进计划（指令与装配）
- 范围
  - 指令最小集：`waf_rules_json`、`waf_jsons_dir`、`waf_json_extends_max_depth`、`waf_trust_xff`、`waf_shm_zone`、`waf_json_log`、`waf_json_log_level`
  - 装配链路：postconfiguration 钩子中，按指令解析入口 JSON → 调 M1 合并 → 调 M2 编译 → 将快照落入 `loc_conf`
  - 引入动作/日志模块存根（接口齐全，行为最小）
- 任务拆分
  - 指令实现与 http/srv/loc 继承合并（`src/module/ngx_http_waf_config.[ch]`）
  - 解析与装配流程（`src/module/ngx_http_waf_module.c` 里 postconfiguration/merge 处调用 JSON+编译）
  - 日志指令接入（路径/级别），将配置挂 `main_conf`
  - “waf:” 前缀的可读日志输出覆盖 dry-run（`nginx -t -q`）路径
- DoD
  - `nginx -t` 通过；入口/目录/深度生效；http/srv/loc 继承符合预期
  - 示例 `nginx.conf` 最小链路跑通（启用模块、声明 `waf_rules_json`，可见“waf: merged rules ...”）
  - 动作/日志模块接口齐备，stub 返回值正确，不阻塞后续接入
- 依赖/风险
  - 依赖 M1/M2 已就绪
  - 风险点：merge 逻辑与路径解析；建议先写 3 份微型样例配置验证继承与覆盖

---

## M4 推进计划（执行管线 ACCESS）
- 范围
  - 5 段流水线：IP 允许 → IP 拒绝 → 信誉评分/封禁 → URI 允许 → 检测段
  - 目标提取工具与短路；异步请求体三段式处理与回调推进
  - 动作/日志接入：规则命中与系统事件（baseAccess、ban、bypass）统一通过动作出口与日志接口
- 任务拆分
  - ACCESS 入口骨架与短路路径（GET/HEAD/0 长度体走快速通道）
  - 体处理三段式（读取→收集→执行）：参考 v1 的 `ngx_http_read_client_request_body` + 回调推进；完善“仅在拦截时 finalize，放行时相位推进”
  - 目标提取：URI/ARGS_COMBINED/ARGS_NAME/ARGS_VALUE/BODY/HEADER；ARGS 解码只在需要时做，避免重复开销
  - 编译快照对接：按 `phase/target` 分桶遍历；检测段内部 `priority` 稳定排序
  - 动作/日志：所有命中统一 `waf_enforce` + `waf_log_append_event[ _complete ]`，末尾 `waf_log_flush`
- DoD
  - 集成测试：GET/POST/大体；BYPASS/BLACKLIST 路径生效；BLOCK 时 403
  - 日志：BLOCK 请求输出完整溯源（含 baseAccess、rule 命中、ban）；普通请求默认不产生日志或仅在级别允许时产出
- 依赖/风险
  - 依赖 M3 装配好快照
  - 风险点：请求体回调推进、跨路径 return 值统一；建议先上 3 条最小规则跑通链路，再扩展

---

## 异步请求体处理（建议实现要点）
- 何时读取：非 GET/HEAD 且 `content_length_n > 0` 或分块 → 异步读取；否则走空体通道。
- 收集：遍历 bufs，优先文件缓冲，统一拷贝到一次分配的请求内存（尾部追加 `\0` 便于匹配器）。
- 解码：仅在需要时（`x-www-form-urlencoded` 和 ARGS）做 `ngx_unescape_uri`，避免重复解码。
- 回调推进：
  - BLOCK：`ngx_http_finalize_request(r, 403)` 等 HTTP 码
  - 放行：`r->phase_handler++; ngx_http_core_run_phases(r);`
- 返回值约定：严格区分 Nginx 内部码与 HTTP 码，保持与 v1 一致但语义更清晰。

---

## 指令与配置建议归档
- 放在 Nginx 指令（而非 JSON）：
  - 全局统一动作：`waf_default_action BLOCK|LOG`（v2.0 初版不纳入 RATELIMIT/柔性倍率）
  - JSONL：`waf_json_log`、`waf_json_log_level`
  - 动态封禁：`waf_shm_zone`、阈值/窗口/时长等
- 原因：运维策略/记录策略是运行面 concern，需 `-t` 验证与热更新；与数据面规则（JSON）解耦。

---

## 与 `milestones.md` 的对齐与勾选提示
- M3 完成后可勾：
  - 指令最小集、生效链路（nginx -t 通过；示例配置可跑）
  - 存根：`ngx_http_waf_action.*`、`ngx_http_waf_log.*` 接口齐备（实现先最小）
- M4 完成后可勾：
  - 5 段执行链路、体处理回调与短路、最小用例通过
  - 日志：BLOCK 路径完整溯源；级别逻辑符合“完整性接口+常规接口+最终 flush”设计

---

## 下一步具体落地顺序（建议）
1) M3
   - 指令实现与继承（含 `waf_json_log*`）
   - postconfiguration 装配：M1→M2→挂载快照
   - 动作/日志存根落地（接口入参与返回约定稳定）
   - 示例 `nginx.conf` + `nginx -t -q` 跑通
2) M4
   - ACCESS 骨架与 GET/HEAD 快通
   - 体处理三段式与回调推进
   - 分桶遍历 + priority 排序
   - 动作/日志接入与最终 flush
   - 集成测试（含 BLOCK 与 BYPASS）

如果同意以上方案，我会据此开始分别起草 `src/core/ngx_http_waf_action.[ch]` 与 `src/core/ngx_http_waf_log.[ch]` 的头文件接口与存根实现，并在 `src/module/ngx_http_waf_config.[ch]` 增加 `waf_json_log`/`waf_json_log_level` 指令以解锁 M3 装配链路。