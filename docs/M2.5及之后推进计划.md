我先检查代码库里是否已有 `action/log/shm` 存根与相关指令（对应 M2.5 的 DoD），包括 `waf_enforce`、`waf_json_log[_level]`、`waf_shm_zone` 等定义及其接入点。随后给出是否“已完成 M2.5”的结论与下一步具体做法。
Ran tool
Ran tool
Ran tool
Ran tool
Ran tool

我先并行打开相关源码，确认 `action/log/shm` 存根与指令是否已按 M2.5 的 DoD 落地。随后判断是否“完成 M2.5”，并给出后续具体做法。
Ran tool
Ran tool
Ran tool
Ran tool
Ran tool
Ran tool
Ran tool
Ran tool

我刚并行检查了 `src/core` 与 `src/module`，对照 `docs/milestones.md` 的 M2.5 DoD 做了逐项核对。

### 结论（是否完成 M2.5）
- 已完成（满足 DoD 的部分）：
  - 统一动作存根（BLOCK 返回 403；LOG/BYPASS 返回 NGX_DECLINED；聚合至 ctx，待最终 flush）：
```30:63:/home/william/myNginxWorkspace/nginx-http-waf-module-v2/src/core/ngx_http_waf_action.c
ngx_int_t waf_enforce(ngx_http_request_t* r,
                      ngx_http_waf_main_conf_t* mcf,
                      ngx_http_waf_loc_conf_t* lcf,
                      ngx_http_waf_ctx_t* ctx,
                      waf_intent_e intent,
                      ngx_int_t http_status,
                      ngx_uint_t rule_id_or_0) {
    (void)mcf; (void)lcf; /* 存根阶段未用 */

    if (http_status <= 0) {
        http_status = NGX_HTTP_FORBIDDEN;
    }

    waf_record_event(r, ctx, intent, rule_id_or_0);

    /* 策略：当全局策略 BLOCK 且意图 BLOCK → 实际阻断 */
    if (waf_global_block_policy_enabled && intent == WAF_INTENT_BLOCK) {
        if (ctx) {
            ctx->final_action = 1; /* BLOCK */
            ctx->final_status = (ngx_uint_t)http_status;
            if (ctx->effective_level < WAF_LOG_ERROR) {
                ctx->effective_level = WAF_LOG_ERROR;
            }
        }
        return http_status;
    }

    /* 非阻断路径 */
    if (ctx) {
        ctx->final_action = (intent == WAF_INTENT_BYPASS) ? 3 : 2;
        ctx->final_status = 0;
    }
    return NGX_DECLINED;
}
```
  - 日志存根（请求内聚合，flush 时输出一行 error_log 摘要）：
```59:66:/home/william/myNginxWorkspace/nginx-http-waf-module-v2/src/core/ngx_http_waf_log.c
    /* 存根阶段：统一输出一行 error_log 日志，包含最终状态/动作/级别/score */
    ngx_log_error(NGX_LOG_NOTICE, r->connection->log, 0,
                  "waf-stub-log: final_status=%ui final_action=%ui level=%s total_score=%ui uri=\"%V\"",
                  ctx->final_status,
                  ctx->final_action,
                  waf_log_level_str(ctx->effective_level),
                  ctx->total_score,
                  &r->uri);
```
  - 指令骨架包含 `waf_json_log`/`waf_json_log_level` 与 `waf_shm_zone`（先存储原始参数，未解析/创建 zone）：
```160:181:/home/william/myNginxWorkspace/nginx-http-waf-module-v2/src/module/ngx_http_waf_config.c
    {
        ngx_string("waf_shm_zone"),
        NGX_HTTP_MAIN_CONF | NGX_CONF_TAKE12,
        ngx_conf_set_str_slot, /* 存根：保存原始字符串，M5 解析 */
        NGX_HTTP_MAIN_CONF_OFFSET,
        offsetof(ngx_http_waf_main_conf_t, shm_zone_raw),
        NULL
    },
    {
        ngx_string("waf_json_log"),
        NGX_HTTP_MAIN_CONF | NGX_CONF_TAKE1,
        ngx_conf_set_str_slot,
        NGX_HTTP_MAIN_CONF_OFFSET,
        offsetof(ngx_http_waf_main_conf_t, json_log_path),
        NULL
    },
    {
        ngx_string("waf_json_log_level"),
        NGX_HTTP_MAIN_CONF | NGX_CONF_TAKE1,
        ngx_conf_set_num_slot,
        NGX_HTTP_MAIN_CONF_OFFSET,
        offsetof(ngx_http_waf_main_conf_t, json_log_level),
        NULL
    },
```
  - ACCESS 最小链路能够调用 action/log 接口（示例对非 GET/HEAD 走 LOG + 立即 flush）：
```38:47:/home/william/myNginxWorkspace/nginx-http-waf-module-v2/src/module/ngx_http_waf_module.c
    (void)waf_enforce(r, ngx_http_get_module_main_conf(r, ngx_http_waf_module),
                      ngx_http_get_module_loc_conf(r, ngx_http_waf_module),
                      ctx, WAF_INTENT_LOG, 0, 0);

    /* 仅在此示例中立即 flush（真实实现中在最终动作处统一 flush） */
    waf_log_flush(r,
                  ngx_http_get_module_main_conf(r, ngx_http_waf_module),
                  ngx_http_get_module_loc_conf(r, ngx_http_waf_module),
                  ctx);
```

- 未完成（未满足 DoD 的关键点）：
  - 动态封禁共享内存并未实际创建 `ngx_shm_zone_t`，`waf_dyn_init_shm_zone` 为空实现，`waf_dyn_is_banned` 恒未封禁：
```14:30:/home/william/myNginxWorkspace/nginx-http-waf-module-v2/src/core/ngx_http_waf_dynamic_block.c
void waf_dyn_init_shm_zone(ngx_cycle_t* cycle) {
    (void)cycle; /* 存根：暂不初始化共享内存结构 */
}

void waf_dyn_score_add(ngx_http_request_t* r, ngx_uint_t delta) {
    if (r == NULL) return;
    /* 存根：无专用 ctx 存取；改为静默 */
    ngx_http_waf_ctx_t* ctx = NULL;
    (void)ctx; /* 占位避免未使用警告 */
    (void)delta;
}

ngx_flag_t waf_dyn_is_banned(ngx_http_request_t* r) {
    (void)r;
    /* 存根阶段恒返回未封禁 */
    return 0;
}
```

- 结论：M2.5 “部分完成”，尚未达到 DoD 的“共享内存创建成功但不执法”。不能打勾为“完成”。可以勾选子项：action/log 存根完成；dynamic_block 的 shm 创建未完成。

### 之后的具体做法（精炼待办）
- 补齐 M2.5（优先）
  - 在 `waf_shm_zone` 指令中解析 `<name> <size>`，调用 `ngx_shared_memory_add` 创建 zone，设置 `init` 回调（如 `waf_dyn_shm_init`），把 `zone->data` 绑定到自定义 `waf_shm_ctx`。
  - 在 `waf_dyn_shm_init` 初始化 `ngx_slab_pool`、`ngx_rbtree_t`（含 `sentinel`）与 `ngx_queue_t`（LRU），准备 `ngx_shmtx_t`。
  - 先保持 `waf_dyn_is_banned()` 恒未封禁，但确保 shm 生命周期正确、并发安全。
- 微调 flush 触发点
  - 在“最终动作处”统一调用 `waf_log_flush`；当前演示用的即时 flush 仅保留在示例代码路径。
- 然后进入 M3（装配链路验收）
  - 确认 http/srv/loc 级 `waf_rules_json` 的继承生效；`nginx -t -q` 能输出 `waf:` 合并摘要；失败时能输出 `file/json_pointer`。
- M4（最小执行管线）
  - 打通 IP 允许/拒绝与 URI BYPASS 的短路分支；检测段先跑少量 CONTAINS/REGEX；命中后通过 `waf_enforce` 产出 403 或记录。
- M5（动态封禁最小可用）
  - 在评分 API 中读取入口 JSON 透传的 `policies.dynamicBlock.baseAccessScore`，更新 ctx 分数；阈值命中后由统一动作出口二次封禁检查。

- 是否“暂时不按里程碑”：不必改路线。我们继续按 `milestones.md`，先把 M2.5 补到“共享内存创建成功（不执法）”，再推进 M3→M4→M5。

- 小提示：目前示例路径仅对非 GET/HEAD 调用 `WAF_INTENT_LOG`，要验证 BLOCK 行为需在后续 M4 的规则命中分支调用 `waf_enforce(..., WAF_INTENT_BLOCK, 403, ruleId)` 并在最终动作处 flush。

- 简短总结
  - M2.5：action/log 已到位；dynamic_block 的 shm 未创建，尚未达成 DoD。
  - 下一步：实现 `waf_shm_zone` → `ngx_shared_memory_add` + `init` 回调，初始化 rbtree/queue/slab；统一 flush 时机；随后进入 M3/M4/M5。